    |\^/|     Maple 7 (IBM INTEL LINUX)
._|\|   |/|_. Copyright (c) 2001 by Waterloo Maple Inc.
 \  MAPLE  /  All rights reserved. Maple is a registered trademark of
 <____ ____>  Waterloo Maple Inc.
      |       Type ? for help.
# util.maple -- misc utility routines
# $Header$
> 
#
# fix_rationals - convert numbers to RATIONAL() calls
# nonmatching_names - find names in a list which *don't* have a specified prefix
# sprint_numeric_list - convert a numeric list to a valid C identifier suffix
# print_name_list_dcl - print C declarations for a list of names
#
# hypercube_points - compute all (integer) points in an N-dimensional hypercube
#
# ftruncate - truncate a file to zero length
#
> 
################################################################################
################################################################################
################################################################################
> 
#
# This function converts all {integer, rational} subexpressions of its
# input except integer exponents and -1 factors in products, into function
# calls
#	RATIONAL(num,den)
# This is useful in conjunction with the  C() library function, since
#
#	C( (1/3) * foo * bar )
#		t0 = foo*bar/3;
#
# generates a (slow) division (and runs the risk of mixed-mode-arithmetic
# problems), while
#
#	C((1.0/3.0) * foo * bar);
#	     t0 = 0.3333333333*foo*bar;
#
# suffers from roundoff error.  With this function,
#
#	fix_rationals((1/3) * foo * bar);
#	     RATIONAL(1,3) foo bar
#	C(%);
#	     t0 = RATIONAL(1.0,3.0)*foo*bar;
#
# which a C preprocessor macro can easily convert to the desired
#
#	     t0 = (1.0/3.0)*foo*bar;
#
# Additionally, this function can be told to leave certain types of
# subexpressions unconverged.  For example,
#	fix_rationals(expr, type, specfunc(integer, DATA));
# will leave all subexpressions of the form  DATA(integer arguments)
# unconverted.
#
# Arguments:
# expr = (in) The expression to be converted.
# inert_fn = (optional in)
#	     If specified, this argument should be a Boolean procedure
#	     or the name of a Boolean procedure.  This procedure should
#	     take one or more argument, and return true if and only if
#	     the first argument should *not* be converted, i.e. if we
#	     should leave this expression unchanged.  See the last
#	     example above.
# ... = (optional in)
#	Any further arguments are passed as additional arguments to
#	the inert_fn procedure.
#
> fix_rationals :=
> proc(
>     expr::{
> 	        algebraic, name = algebraic,
> 	  list({algebraic, name = algebraic}),
> 	  set ({algebraic, name = algebraic})
> 	  },
>     inert_fn::{name, procedure}
>     )
> local nn, k,
>       base, power, fbase, fpower,
>       fn, fn_args_list,
>       num, den, mult;
> 
# do we want to convert this expression?
> if ((nargs >= 2) and inert_fn(expr, args[3..nargs]))
>    then return expr;
> end if;
> 
# recurse over lists and sets
> if (type(expr, {list,set}))
>    then return map(fix_rationals, expr, args[2..nargs]);
> end if;
> 
# recurse over equation right hand sides
> if (type(expr, name = algebraic))
>    then return ( lhs(expr) = fix_rationals(rhs(expr), args[2..nargs]) );
> end if;
> 
# recurse over functions other than  RATIONAL()
> if (type(expr, function))
>    then
> 	fn := op(0, expr);
> 	if (fn <> 'RATIONAL')
> 	   then
> 		fn_args_list := [op(expr)];
> 		fn_args_list := map(fix_rationals, fn_args_list, args[2..nargs]);
> 		fn; return '%'( op(fn_args_list) );
> 	end if;
> end if;
> 
> nn := nops(expr);
> 
# recurse over sums
> if (type(expr, `+`))
>    then return sum('fix_rationals(op(k,expr), args[2..nargs])', 'k'=1..nn);
> end if;
> 
# recurse over products
# ... leaving leading -1 factors intact, i.e. not converted to RATIONAL(-1,1)
> if (type(expr, `*`))
>    then
> 	if (op(1, expr) = -1)
> 	   then return -1*fix_rationals(remove(type, expr, 'identical(-1)'),
> 				        args[2..nargs]);
> 	   else return product('fix_rationals(op(k,expr), args[2..nargs])',
> 			       'k'=1..nn);
> 	end if;
> end if;
> 
# recurse over powers
# ... leaving integer exponents intact
> if (type(expr, `^`))
>    then
> 	base := op(1, expr);
> 	power := op(2, expr);
> 
> 	fbase := fix_rationals(base, args[2..nargs]);
> 	if (type(power, integer))
> 	   then fpower := power;
> 	   else fpower := fix_rationals(power, args[2..nargs]);
> 	end if;
> 	return fbase ^ fpower;
> end if;
> 
# fix integers and fractions
> if (type(expr, integer))
>    then return 'RATIONAL'(expr, 1);
> end if;
> if (type(expr, fraction))
>    then
> 	num := op(1, expr);
> 	den := op(2, expr);
> 
> 	return 'RATIONAL'(num, den);
> end if;
> 
# turn Maple floating-point into integer fraction, then recursively fix that
> if (type(expr, float))
>    then
> 	mult := op(1, expr);
> 	power := op(2, expr);
> 	return fix_rationals(mult * 10^power, args[2..nargs]);
> end if;
> 
# identity op on names
> if (type(expr, name))
>    then return expr;
> end if;
> 
# unknown type
> error "%0",
>       "unknown type for expr!",
>       "   whattype(expr) = ", whattype(expr),
>       "   expr = ", expr;
> end proc;
fix_rationals := proc(expr::{algebraic, name = algebraic,
list({algebraic, name = algebraic}), set({algebraic, name = algebraic})},
inert_fn::{procedure, name})
local nn, k, base, power, fbase, fpower, fn, fn_args_list, num, den, mult;
    if 2 <= nargs and inert_fn(expr, args[3 .. nargs]) then return expr
    end if;
    if type(expr, {set, list}) then
        return map(fix_rationals, expr, args[2 .. nargs])
    end if;
    if type(expr, name = algebraic) then
        return lhs(expr) = fix_rationals(rhs(expr), args[2 .. nargs])
    end if;
    if type(expr, function) then
        fn := op(0, expr);
        if fn <> 'RATIONAL' then
            fn_args_list := [op(expr)];
            fn_args_list :=
                map(fix_rationals, fn_args_list, args[2 .. nargs]);
            fn;
            return '%'(op(fn_args_list))
        end if
    end if;
    nn := nops(expr);
    if type(expr, `+`) then return
        sum('fix_rationals(op(k, expr), args[2 .. nargs])', 'k' = 1 .. nn)
    end if;
    if type(expr, `*`) then
        if op(1, expr) = -1 then return -fix_rationals(
            remove(type, expr, 'identical(-1)'), args[2 .. nargs])
        else return product('fix_rationals(op(k, expr), args[2 .. nargs])',
            'k' = 1 .. nn)
        end if
    end if;
    if type(expr, `^`) then
        base := op(1, expr);
        power := op(2, expr);
        fbase := fix_rationals(base, args[2 .. nargs]);
        if type(power, integer) then fpower := power
        else fpower := fix_rationals(power, args[2 .. nargs])
        end if;
        return fbase^fpower
    end if;
    if type(expr, integer) then return 'RATIONAL'(expr, 1) end if;
    if type(expr, fraction) then
        num := op(1, expr); den := op(2, expr); return 'RATIONAL'(num, den)
    end if;
    if type(expr, float) then
        mult := op(1, expr);
        power := op(2, expr);
        return fix_rationals(mult*10^power, args[2 .. nargs])
    end if;
    if type(expr, name) then return expr end if;
    error "%0", "unknown type for expr!", "   whattype(expr) = ",
        whattype(expr), "   expr = ", expr
end proc

> 
################################################################################
> 
#
# This function finds names in a list which *don't* have a specified prefix.
#
# Arguments:
# name_list = A list of the names.
# prefix = The prefix we want to filter out.
#
# Results:
# This function returns the subset list of names which don't have the
# specified prefix.
# 
> nonmatching_names :=
> proc( name_list::list({name,string}), prefix::{name,string} )
> 
> select(   proc(n)
> 	  evalb(not StringTools[IsPrefix](prefix,n));
> 	  end proc
> 	,
> 	  name_list
>       );
> end proc;
nonmatching_names := proc(
name_list::list({name, string}), prefix::{name, string})
    select(proc(n) evalb(not StringTools[IsPrefix](prefix, n)) end proc,
    name_list)
end proc

> 
################################################################################
> 
#
# This function converts a numeric list to a string which is a valid
# C identifier suffix: elements are separated by "_", decimal points are
# replaced by "x", and all nonzero values have explicit +/- signs, which
# are replaced by "p"/"m".
#
# For example, [0,-3.5,+4] --> "0_m3x5_p4".
#
> sprint_numeric_list :=
> proc(nlist::list(numeric))
> 
# generate preliminary string, eg "+0_-3.5_+4"
> map2(sprintf, "%+a", nlist);
> ListTools[Join](%, "_");
> cat(op(%));
> 
# fixup bad characters
> StringTools[SubstituteAll](%, "+0", "0");
> StringTools[CharacterMap](".+-", "xpm", %);
> 
> return %;
> end proc;
sprint_numeric_list := proc(nlist::list(numeric))
    map2(sprintf, "%+a", nlist);
    ListTools[Join](%, "_");
    cat(op(%));
    StringTools[SubstituteAll](%, "+0", "0");
    StringTools[CharacterMap](".+-", "xpm", %);
    return %
end proc

> 
################################################################################
> 
#
# This function prints a sequence of C declarations for a list of names.
#
# Argument:
# name_list = A list of the names.
# type_name = The C type of the names, eg. "double".
# file_name = The file name to write the declaration to.  This is
#	      truncated before writing.
#
> print_name_list_dcl :=
> proc( name_list::list({name,string}),
>       type_name::string,
>       file_name::string )
> local blanks, separator_string;
> 
> ftruncate(file_name);
> 
> map(
>        proc(var::{name,string})
>        fprintf(file_name,
> 	       "%s %s;\n", 
> 	       type_name, var);
>        end proc
>      ,
>        name_list
>    );
> 
> fclose(file_name);
> NULL;
> end proc;
print_name_list_dcl := proc(
name_list::list({name, string}), type_name::string, file_name::string)
local blanks, separator_string;
    ftruncate(file_name);
    map(proc(var::{name, string})
            fprintf(file_name, "%s %s;\n", type_name, var)
        end proc, name_list);
    fclose(file_name);
    NULL
end proc

> 
################################################################################
################################################################################
################################################################################
> 
#
# This function computes a list of all the (integer) points in an
# N-dimensional hypercube, in lexicographic order.  The present
# implementation requires N <= 4.
#
# Arguments:
# cmin,cmax = N-element lists of cube minimum/maximum coordinates.
#
# Results:
# The function returns a set of d-element lists giving the coordinates.
# For example,
#	hypercube([0,0], [2,1]
# returns
#	{ [0,0], [0,1], [1,0], [1,1], [2,0], [2,1] }
> hypercube_points :=
> proc(cmin::list(integer), cmax::list(integer))
> local N, i,j,k,l;
> 
> N := nops(cmin);
> if (nops(cmax) <> N)
>    then error 
> 	"must have same number of dimensions for min and max coordinates!";
> fi;
> 
> if   (N = 1)
>    then return [seq([i], i=cmin[1]..cmax[1])];
> elif (N = 2)
>    then return [
> 		 seq(
> 		   seq([i,j], j=cmin[2]..cmax[2]),
> 		   i=cmin[1]..cmax[1])
> 	       ];
> elif (N = 3)
>    then return [
> 		 seq(
> 		   seq(
> 		     seq([i,j,k], k=cmin[3]..cmax[3]),
> 		     j=cmin[2]..cmax[2] ),
> 		   i=cmin[1]..cmax[1])
> 	       ];
> elif (N = 4)
>    then return [
> 		 seq(
> 		   seq(
> 		     seq(
> 		       seq([i,j,k,l], l=cmin[4]..cmax[4]),
> 		       k=cmin[3]..cmax[3] ),
> 		     j=cmin[2]..cmax[2]),
> 		   i=cmin[1]..cmax[1])
> 	       ];
> else
> 	error "implementation restriction: must have N <= 4, got %1!", N;
> fi;
> end proc;
hypercube_points := proc(cmin::list(integer), cmax::list(integer))
local N, i, j, k, l;
    N := nops(cmin);
    if nops(cmax) <> N then error
        "must have same number of dimensions for min and max coordinates!"
    end if;
    if N = 1 then return [seq([i], i = cmin[1] .. cmax[1])]
    elif N = 2 then return
        [seq(seq([i, j], j = cmin[2] .. cmax[2]), i = cmin[1] .. cmax[1])]
    elif N = 3 then return [seq(
        seq(seq([i, j, k], k = cmin[3] .. cmax[3]), j = cmin[2] .. cmax[2])
        , i = cmin[1] .. cmax[1])]
    elif N = 4 then return [seq(seq(seq(
        seq([i, j, k, l], l = cmin[4] .. cmax[4]), k = cmin[3] .. cmax[3]),
        j = cmin[2] .. cmax[2]), i = cmin[1] .. cmax[1])]
    else error "implementation restriction: must have N <= 4, got %1!", N
    end if
end proc

> 
################################################################################
################################################################################
################################################################################
> 
#
# This function truncates a file to 0 length if it exists, or creates
# it at that length if it doesn't exist.
#
# Arguments:
# file_name = (in) The name of the file.
#
> ftruncate :=
> proc(file_name::string)
> fopen(file_name, 'WRITE');
> fclose(%);
> NULL;
> end proc;
ftruncate :=

    proc(file_name::string) fopen(file_name, 'WRITE'); fclose(%); NULL end proc

# interpolate.maple -- compute interpolation formulas/coefficients
# $Header$
> 
#
# <<<representation of numbers, data values, etc>>>
# Lagrange_polynomial_interpolant - compute Lagrange polynomial interpolant
# Hermite_polynomial_interpolant - compute Hermite polynomial interpolant
# coeff_as_lc_of_data - coefficients of ... (linear combination of data)
#
# print_coeff__lc_of_data - print C code to compute coefficients
# print_fetch_data - print C code to fetch input array chunk into struct data
# print_store_coeffs - print C code to store struct coeffs "somewhere"
# print_interp_cmpt__lc_of_data - print C code for computation of interpolant
#
# coeff_name - name of coefficient of data at a given [m] coordinate
# data_var_name - name of variable storing data value at a given [m] coordinate
#
> 
################################################################################
> 
#
# ***** representation of numbers, data values, etc *****
#
# We use RATIONAL(p.0,q.0) to denote the rational number p/q.
#
# We use DATA(...) to represent the data values being interpolated at a
# specified [m] coordinate, where the arguments are the [m] coordinates.
#
# We use COEFF(...) to represent the molecule coefficient at a specified
# [m] coordinate, where the arguments are the [m] coordinates.
#
# For example, the usual 1-D centered 2nd order 1st derivative molecule
# would be written
#	RATIONAL(-1.0,2.0)*DATA(-1) + RATIONA(1.0,2.0)*DATA(1)
# and its coefficients as
#	COEFF(-1) = RATIONAL(-1.0,2.0)
#	COEFF(1) = RATIONAL(1.0,2.0)
#
> 
################################################################################
################################################################################
################################################################################
> 
#
# This function computes a Lagrange polynomial interpolant in any
# number of dimensions.
#
# Arguments:
# fn = The interpolation function.  This should be a procedure in the
#      coordinates, having the coefficients as global variables.  For
#      example,
#	  proc(x,y) c00 + c10*x + c01*y end proc
# coeff_list = A set of the interpolation coefficients (coefficients in
#	       the interpolation function), for example [c00, c10, c01].
# coord_list = A list of the coordinates (independent variables in the
#	       interpolation function), for example [x,y].
# posn_list = A list of positions (each a list of numeric values) where the
#	      interpolant is to use data, for example  hypercube([0,0], [1,1]).
#	      Any positions may be used; if they're redundant (as in the
#	      example) the least-squares interpolant is computed.
#
# Results:
# This function returns the interpolating polynomial, in the form of
# an algebraic expression in the coordinates and the data values.
#
> Lagrange_polynomial_interpolant :=
> proc(
>       fn::procedure, coeff_list::list(name),
>       coord_list::list(name), posn_list::list(list(numeric))
>     )
> local posn, data_eqns, coeff_eqns;
> 
# coefficients of interpolating polynomial
> data_eqns := {  seq( fn(op(posn))='DATA'(op(posn)) , posn=posn_list )  };
> coeff_eqns := linalg[leastsqrs](data_eqns, {op(coeff_list)});
> if (has(coeff_eqns, '_t'))
>    then error "interpolation coefficients aren't uniquely determined!";
> end if;
> 
# interpolant as a polynomial in the coordinates
> return subs(coeff_eqns, eval(fn))(op(coord_list));
> end proc;
Lagrange_polynomial_interpolant := proc(fn::procedure, coeff_list::list(name),
coord_list::list(name), posn_list::list(list(numeric)))
local posn, data_eqns, coeff_eqns;
    data_eqns := {seq(fn(op(posn)) = 'DATA'(op(posn)), posn = posn_list)};
    coeff_eqns := linalg[leastsqrs](data_eqns, {op(coeff_list)});
    if has(coeff_eqns, '_t') then
        error "interpolation coefficients aren't uniquely determined!"
    end if;
    return subs(coeff_eqns, eval(fn))(op(coord_list))
end proc

> 
################################################################################
> 
#
# This function computes a Hermite polynomial interpolant in any
# number of dimensions.  This is a polynomial which
# * has values which match the given data DATA() at a specified set of
#   points, and
# * has derivatives which match the specified finite-difference derivatives
#   of the given data DATA() at a specified set of points
#
# For the derivative matching, we actually match all possible products
# of 1st derivatives, i.e. in 2-D we match dx, dy, and dxy, in 3-D we
# match dx, dy, dz, dxy, dxz, dyz, and dxyz, etc etc.
#
# Arguments:
# fn = The interpolation function.  This should be a procedure in the
#      coordinates, having the coefficients as global variables.  For
#      example,
#		proc(x,y)
#		+ c03*y^3 + c13*x*y^3 + c23*x^2*y^3 + c33*x^3*y^3
#		+ c02*y^2 + c12*x*y^2 + c22*x^2*y^2 + c32*x^3*y^2
#		+ c01*y   + c11*x*y   + c21*x^2*y   + c31*x^3*y
#		+ c00     + c10*x     + c20*x^2     + c30*x^3
#		end proc;
# coeff_set = A set of the interpolation coefficients (coefficients in
#	       the interpolation function), for example
#			{
#			c03, c13, c23, c33,
#			c02, c12, c22, c32,
#			c01, c11, c21, c31,
#			c00, c10, c20, c30
#			}
# coord_list = A list of the coordinates (independent variables in the
#	       interpolation function), for example [x,y].
# deriv_set = A set of equations of the form
#		{coords} = proc
#	      giving the derivatives which are to be matched, and the
#	      procedures to compute their finite-difference approximations.
#	      Each procedure should take N_dims integer arguments specifying
#	      an evaluation point, and return a suitable linear combination
#	      of the DATA() for the derivative at that point.  For example
#			{
#			  {x}   = proc(i::integer, j::integer)
#				  - 1/2*DATA(i-1,j) + 1/2*DATA(i+1,j)
#				  end proc
#			,
#			  {y}   = proc(i::integer, j::integer)
#				  - 1/2*DATA(i,j-1) + 1/2*DATA(i,j+1)
#				  end proc
#			,
#			  {x,y} = proc(i::integer, j::integer)
#				  - 1/4*DATA(i-1,j+1) + 1/4*DATA(i+1,j+1)
#				  + 1/4*DATA(i-1,j-1) - 1/4*DATA(i+1,j-1)
#				  end proc
#			}
# fn_posn_set = A set of positions (each a list of numeric values)
#		where the interpolant is to match the given data DATA(),
#		for example
#			{[0,0], [0,1], [1,0], [1,1]}
# deriv_posn_set = A list of positions (each a list of numeric values)
#		   where the interpolant is to match the derivatives
#		   specified by  deriv_set , for example
#			{[0,0], [0,1], [1,0], [1,1]}
#
# Results:
# This function returns the interpolating polynomial, in the form of
# an algebraic expression in the coordinates and the data values.
#
> Hermite_polynomial_interpolant :=
> proc(
>       fn::procedure,
>       coeff_set::set(name),
>       coord_list::list(name),
>       deriv_set::set(set(name) = procedure),
>       fn_posn_set::set(list(numeric)),
>       deriv_posn_set::set(list(numeric))
>     )
> local fn_eqnset, deriv_eqnset, coeff_eqns, subs_eqnset;
> 
> 
#
# compute a set of equations
#	{fn(posn) = DATA(posn)}
# giving the function values to be matched
#
> fn_eqnset := map(
> 		    # return equation that fn(posn) = DATA(posn)
> 		    proc(posn::list(integer))
> 		    fn(op(posn)) = 'DATA'(op(posn));
> 		    end proc
> 		  ,
> 		    fn_posn_set
> 		);
> 
> 
#
# compute a set of equations
#	{ diff(fn,coords)(posn) = DERIV(coords)(posn) }
# giving the derivative values to be matched, where DERIV(coords)
# is a placeholder for the appropriate derivative
#
> map(
>        # return set of equations for this particular derivative
>        proc(deriv_coords::set(name))
>        local deriv_fn;
>        fn(op(coord_list));
>        diff(%, op(deriv_coords));
>        deriv_fn := unapply(%, op(coord_list));
>        map(
> 	      proc(posn::list(integer))
> 	      deriv_fn(op(posn)) = 'DERIV'(op(deriv_coords))(op(posn));
> 	      end proc
> 	    ,
> 	      deriv_posn_set
> 	  );
>        end proc
>      ,
>        map(lhs, deriv_set)
>    );
> deriv_eqnset := `union`(op(%));
> 
> 
#
# solve overall set of equations for coefficients
# in terms of DATA() and DERIV() values
#
> coeff_eqns := solve[linear](fn_eqnset union deriv_eqnset, coeff_set);
> if (indets(map(rhs,%)) <> {})
>    then error "no unique solution for coefficients -- %1 eqns for %2 coeffs",
> 	      nops(fn_eqnset union deriv_eqnset),
> 	      nops(coeff_set);
> fi;
> 
> 
#
# compute a set of substitution equations
#	{'DERIV'(coords) = procedure}
#
> subs_eqnset := map(
> 		      proc(eqn::set(name) = procedure)
> 		      'DERIV'(op(lhs(eqn))) = rhs(eqn);
> 		      end proc
> 		    ,
> 		      deriv_set
> 		  );
> 
> 
#
# compute the coefficients in terms of the DATA() values
#
> subs(subs_eqnset, coeff_eqns);
> eval(%);
> 
#
# compute the interpolant as a polynomial in the coordinates
#
> subs(%, fn(op(coord_list)));
> end proc;
Hermite_polynomial_interpolant := proc(fn::procedure, coeff_set::set(name),
coord_list::list(name), deriv_set::set(set(name) = procedure),
fn_posn_set::set(list(numeric)), deriv_posn_set::set(list(numeric)))
local fn_eqnset, deriv_eqnset, coeff_eqns, subs_eqnset;
    fn_eqnset := map(
        proc(posn::list(integer)) fn(op(posn)) = 'DATA'(op(posn)) end proc,
        fn_posn_set);
    map(proc(deriv_coords::set(name))
        local deriv_fn;
            fn(op(coord_list));
            diff(%, op(deriv_coords));
            deriv_fn := unapply(%, op(coord_list));
            map(proc(posn::list(integer))
                    deriv_fn(op(posn)) =
                    'DERIV'(op(deriv_coords))(op(posn))
                end proc, deriv_posn_set)
        end proc, map(lhs, deriv_set));
    deriv_eqnset := `union`(op(%));
    coeff_eqns := solve[linear](fn_eqnset union deriv_eqnset, coeff_set);
    if indets(map(rhs, %)) <> {} then error
        "no unique solution for coefficients -- %1 eqns for %2 coeffs",
        nops(fn_eqnset union deriv_eqnset), nops(coeff_set)
    end if;
    subs_eqnset := map(proc(eqn::(set(name) = procedure))
            'DERIV'(op(lhs(eqn))) = rhs(eqn)
        end proc, deriv_set);
    subs(subs_eqnset, coeff_eqns);
    eval(%);
    subs(%, fn(op(coord_list)))
end proc

> 
################################################################################
> 
#
# This function takes as input an interpolating polynomial, expresses
# it as a linear combination of the data values, and returns the coefficeints
# of that form.
# 
# Arguments:
# interpolant = The interpolating polynomial (an algebraic expression
#		in the coordinates and the data values).
# posn_list = The same list of data positions used in the interpolant.
#
# Results:
# This function returns the coefficients, as a list of equations of the
# form   COEFF(...) = value , where each  value  is a polynomial in the
# coordinates.  The order of the list matches that of  posn_list.
#
> coeff_as_lc_of_data :=
> proc(
>       interpolant::algebraic,
>       posn_list::list(list(numeric))
>     )
> local data_list, interpolant_as_lc_of_data;
> 
# interpolant as a linear combination of the data values
> data_list := [ seq( 'DATA'(op(posn)) , posn=posn_list ) ];
> interpolant_as_lc_of_data := collect(interpolant, data_list);
> 
# coefficients of the data values in the linear combination
> return map(
> 	      proc(posn::list(numeric))
> 	      coeff(interpolant_as_lc_of_data, DATA(op(posn)));
> 	      'COEFF'(op(posn)) = %;
> 	      end proc
> 	    ,
> 	      posn_list
> 	  );
> end proc;
coeff_as_lc_of_data := proc(
interpolant::algebraic, posn_list::list(list(numeric)))
local data_list, interpolant_as_lc_of_data;
    data_list := [seq('DATA'(op(posn)), posn = posn_list)];
    interpolant_as_lc_of_data := collect(interpolant, data_list);
    return map(proc(posn::list(numeric))
            coeff(interpolant_as_lc_of_data, DATA(op(posn)));
            'COEFF'(op(posn)) = %
        end proc, posn_list)
end proc

> 
################################################################################
################################################################################
################################################################################
> 
#
# This function prints C expressions for the coefficients of an
# interpolating polynomial.  (The polynomial is expressed as linear
# combinations of the data values with coefficients which are
# RATIONAL(p,q) calls.)
#
# Arguments:
# coeff_list = A list of the coefficients, as returned from
#	       coeff_as_lc_of_data() .
# coeff_name_prefix = A prefix string for the coefficient names.
# temp_name_type = The C type to be used for Maple-introduced temporary
#		   names, eg. "double".
# file_name = The file name to write the coefficients to.  This is
#	      truncated before writing.
#
> print_coeff__lc_of_data :=
> proc( coeff_list::list(specfunc(numeric,COEFF) = algebraic),
>       coeff_name_prefix::string,
>       temp_name_type::string,
>       file_name::string )
> global `codegen/C/function/informed`;
> local coeff_list2, cmpt_list, temp_name_list;
> 
# convert LHS of each equation from a COEFF() call (eg COEFF(-1,+1))
# to a Maple/C variable name (eg coeff_I_m1_p1)
> coeff_list2 := map(
> 		      proc(coeff_eqn::specfunc(numeric,COEFF) = algebraic)
> 		      local posn;
> 		      posn := [op(lhs(coeff_eqn))];
> 		      coeff_name(posn,coeff_name_prefix);
> 		      convert(%, name);	# codegen[C] wants LHS
> 					# to be an actual Maple *name*
> 		      % = fix_rationals(rhs(coeff_eqn));
> 		      end proc
> 		    ,
> 		      coeff_list
> 		  );
> 
#
# generate the C code
#
> 
# tell codegen[C] not to warn about unknown RATIONAL() and DATA() "fn calls"
# via undocumented :( global table
> `codegen/C/function/informed`['RATIONAL'] := true;
> `codegen/C/function/informed`['DATA'] := true;
> 
> ftruncate(file_name);
> 
# optimized computation sequence for all the coefficients
# (may use local variables t0,t1,t2,...)
> cmpt_list := [codegen[optimize](coeff_list2, tryhard)];
> 
# list of the t0,t1,t2,... local variables
> temp_name_list := nonmatching_names(map(lhs,cmpt_list), coeff_name_prefix);
> 
# declare the t0,t1,t2,... local variables (if there are any)
> if (nops(temp_name_list) > 0)
>    then print_name_list_dcl(%, temp_name_type, file_name);
> fi;
> 
# now print the optimized computation sequence
> codegen[C](cmpt_list, filename=file_name);
> 
> fclose(file_name);
> 
> NULL;
> end proc;
print_coeff__lc_of_data := proc(
coeff_list::list(specfunc(numeric, COEFF) = algebraic),
coeff_name_prefix::string, temp_name_type::string, file_name::string)
local coeff_list2, cmpt_list, temp_name_list;
global `codegen/C/function/informed`;
    coeff_list2 := map(proc(
        coeff_eqn::(specfunc(numeric, COEFF) = algebraic))
        local posn;
            posn := [op(lhs(coeff_eqn))];
            coeff_name(posn, coeff_name_prefix);
            convert(%, name);
            % = fix_rationals(rhs(coeff_eqn))
        end proc, coeff_list);
    `codegen/C/function/informed`['RATIONAL'] := true;
    `codegen/C/function/informed`['DATA'] := true;
    ftruncate(file_name);
    cmpt_list := [codegen[optimize](coeff_list2, tryhard)];
    temp_name_list :=
        nonmatching_names(map(lhs, cmpt_list), coeff_name_prefix);
    if 0 < nops(temp_name_list) then
        print_name_list_dcl(%, temp_name_type, file_name)
    end if;
    codegen[C](cmpt_list, filename = file_name);
    fclose(file_name);
    NULL
end proc

> 
################################################################################
> 
#
# This function prints a sequence of C expression to assign the data-value
# variables, eg
#	data->data_m1_p1 = DATA(-1,1);
#
# Arguments:
# posn_list = The same list of positions as was used to compute the
#	      interpolating polynomial.
# data_var_name_prefix = A prefix string for the data variable names.
# file_name = The file name to write the coefficients to.  This is
#	      truncated before writing.
#
> print_fetch_data :=
> proc(
>       posn_list::list(list(numeric)),
>       data_var_name_prefix::string,
>       file_name::string
>     )
> 
> ftruncate(file_name);
> map(
>        proc(posn::list(numeric))
>        fprintf(file_name,
> 	       "%s = %a;\n",
> 	       data_var_name(posn,data_var_name_prefix),
> 	       DATA(op(posn)));
>        end proc
>      ,
>        posn_list
>    );
> fclose(file_name);
> 
> NULL;
> end proc;
print_fetch_data := proc(posn_list::list(list(numeric)),
data_var_name_prefix::string, file_name::string)
    ftruncate(file_name);
    map(proc(posn::list(numeric))
            fprintf(file_name, "%s = %a;\n",
            data_var_name(posn, data_var_name_prefix), DATA(op(posn)))
        end proc, posn_list);
    fclose(file_name);
    NULL
end proc

> 
################################################################################
> 
#
# This function prints a sequence of C expression to store the interpolation
# coefficients in  COEFF(...)  expressions, eg
#	COEFF(1,-1) = factor * coeffs->coeff_p1_m1;
#
# Arguments:
# posn_list = The list of positions in the molecule.
# coeff_name_prefix = A prefix string for the coefficient names,
#		      eg "factor * coeffs->coeff_"
# file_name = The file name to write the coefficients to.  This is
#	      truncated before writing.
#
> print_store_coeffs :=
> proc(
>       posn_list::list(list(numeric)),
>       coeff_name_prefix::string,
>       file_name::string
>     )
> 
> ftruncate(file_name);
> map(
>        proc(posn::list(numeric))
>        fprintf(file_name,
> 	       "%a = %s;\n",
> 	       'COEFF'(op(posn)),
> 	       coeff_name(posn,coeff_name_prefix));
>        end proc
>      ,
>        posn_list
>    );
> fclose(file_name);
> 
> NULL;
> end proc;
print_store_coeffs := proc(posn_list::list(list(numeric)),
coeff_name_prefix::string, file_name::string)
    ftruncate(file_name);
    map(proc(posn::list(numeric))
            fprintf(file_name, "%a = %s;\n", 'COEFF'(op(posn)),
            coeff_name(posn, coeff_name_prefix))
        end proc, posn_list);
    fclose(file_name);
    NULL
end proc

> 
################################################################################
> 
#
# This function prints a C expression to evaluate a molecule, i.e.
# to compute the molecule as a linear combination of the data values.
#
# Arguments:
# posn_list = The list of positions in the molecule.
# coeff_name_prefix = A prefix string for the coefficient names.
# data_var_name_prefix = A prefix string for the data variable names.
# file_name = The file name to write the coefficients to.  This is
#	      truncated before writing.
#
> print_evaluate_molecule :=
> proc(
>       posn_list::list(list(numeric)),
>       coeff_name_prefix::string,
>       data_var_name_prefix::string,
>       file_name::string
>     )
> 
> ftruncate(file_name);
> 
# list of "coeff*data_var" terms
> map(
>        proc(posn::list(numeric))
>        sprintf("%s*%s",
> 	       coeff_name(posn,coeff_name_prefix),
> 	       data_var_name(posn,data_var_name_prefix));
>        end proc
>      ,
>        posn_list
>    );
> 
> ListTools[Join](%, "\n  + ");
> cat(op(%));
> fprintf(file_name, "    %s;\n", %);
> 
> fclose(file_name);
> 
> NULL;
> end proc;
print_evaluate_molecule := proc(posn_list::list(list(numeric)),
coeff_name_prefix::string, data_var_name_prefix::string, file_name::string)
    ftruncate(file_name);
    map(proc(posn::list(numeric))
            sprintf("%s*%s", coeff_name(posn, coeff_name_prefix),
            data_var_name(posn, data_var_name_prefix))
        end proc, posn_list);
    ListTools[Join](%, "\n  + ");
    cat(op(%));
    fprintf(file_name, "    %s;\n", %);
    fclose(file_name);
    NULL
end proc

> 
################################################################################
################################################################################
################################################################################
> 
#
# This function computes the name of the coefficient of the data at a
# given [m] position, i.e. it encapsulates our naming convention for this.
#
# Arguments:
# posn = (in) The [m] coordinates.
# name_prefix = A prefix string for the coefficient name.
#
# Results:
# The function returns the coefficient, as a Maple string.
#
> coeff_name :=
> proc(posn::list(numeric), name_prefix::string)
> cat(name_prefix, sprint_numeric_list(posn));
> end proc;
coeff_name := proc(posn::list(numeric), name_prefix::string)
    cat(name_prefix, sprint_numeric_list(posn))
end proc

> 
################################################################################
> 
#
# This function computes the name of the variable in which the C code
# will store the input data at a given [m] position, i.e. it encapsulates
# our naming convention for this.
#
# Arguments:
# posn = (in) The [m] coordinates.
# name_prefix = A prefix string for the variable name.
#
# Results:
# The function returns the variable name, as a Maple string.
#
> data_var_name :=
> proc(posn::list(numeric), name_prefix::string)
> cat(name_prefix, sprint_numeric_list(posn));
> end proc;
data_var_name := proc(posn::list(numeric), name_prefix::string)
    cat(name_prefix, sprint_numeric_list(posn))
end proc

# Maple code to compute lists of point positions in hypercube-shaped molecules
# $Header$
> 
################################################################################
> 
#
# 1D interpolation points
#
> posn_list_1d_size2 := hypercube_points([ 0], [+1]);
                        posn_list_1d_size2 := [[0], [1]]

> posn_list_1d_size3 := hypercube_points([-1], [+1]);
                     posn_list_1d_size3 := [[-1], [0], [1]]

> posn_list_1d_size4 := hypercube_points([-1], [+2]);
                  posn_list_1d_size4 := [[-1], [0], [1], [2]]

> posn_list_1d_size5 := hypercube_points([-2], [+2]);
               posn_list_1d_size5 := [[-2], [-1], [0], [1], [2]]

> posn_list_1d_size6 := hypercube_points([-2], [+3]);
             posn_list_1d_size6 := [[-2], [-1], [0], [1], [2], [3]]

> posn_list_1d_size7 := hypercube_points([-3], [+3]);
          posn_list_1d_size7 := [[-3], [-2], [-1], [0], [1], [2], [3]]

> 
################################################################################
> 
#
# 2D interpolation points (Fortran ordering)
#
> posn_list_2d_size2 := map(ListTools[Reverse],
> 			  hypercube_points([ 0, 0], [+1,+1]));
             posn_list_2d_size2 := [[0, 0], [1, 0], [0, 1], [1, 1]]

> posn_list_2d_size3 := map(ListTools[Reverse],
> 			  hypercube_points([-1,-1], [+1,+1]));
posn_list_2d_size3 := [[-1, -1], [0, -1], [1, -1], [-1, 0], [0, 0], [1, 0],

    [-1, 1], [0, 1], [1, 1]]

> posn_list_2d_size4 := map(ListTools[Reverse],
> 			  hypercube_points([-1,-1], [+2,+2]));
posn_list_2d_size4 := [[-1, -1], [0, -1], [1, -1], [2, -1], [-1, 0], [0, 0],

    [1, 0], [2, 0], [-1, 1], [0, 1], [1, 1], [2, 1], [-1, 2], [0, 2], [1, 2],

    [2, 2]]

> posn_list_2d_size5 := map(ListTools[Reverse],
> 			  hypercube_points([-2,-2], [+2,+2]));
posn_list_2d_size5 := [[-2, -2], [-1, -2], [0, -2], [1, -2], [2, -2], [-2, -1],

    [-1, -1], [0, -1], [1, -1], [2, -1], [-2, 0], [-1, 0], [0, 0], [1, 0],

    [2, 0], [-2, 1], [-1, 1], [0, 1], [1, 1], [2, 1], [-2, 2], [-1, 2], [0, 2],

    [1, 2], [2, 2]]

> posn_list_2d_size6 := map(ListTools[Reverse],
> 			  hypercube_points([-2,-2], [+3,+3]));
posn_list_2d_size6 := [[-2, -2], [-1, -2], [0, -2], [1, -2], [2, -2], [3, -2],

    [-2, -1], [-1, -1], [0, -1], [1, -1], [2, -1], [3, -1], [-2, 0], [-1, 0],

    [0, 0], [1, 0], [2, 0], [3, 0], [-2, 1], [-1, 1], [0, 1], [1, 1], [2, 1],

    [3, 1], [-2, 2], [-1, 2], [0, 2], [1, 2], [2, 2], [3, 2], [-2, 3], [-1, 3],

    [0, 3], [1, 3], [2, 3], [3, 3]]

> 
################################################################################
> 
#
# 3D interpolation points (Fortran ordering)
#
> posn_list_3d_size2 := map(ListTools[Reverse],
> 			  hypercube_points([ 0, 0, 0], [+1,+1,+1]));
posn_list_3d_size2 := [[0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 0], [0, 0, 1],

    [1, 0, 1], [0, 1, 1], [1, 1, 1]]

> posn_list_3d_size3 := map(ListTools[Reverse],
> 			  hypercube_points([-1,-1,-1], [+1,+1,+1]));
posn_list_3d_size3 := [[-1, -1, -1], [0, -1, -1], [1, -1, -1], [-1, 0, -1],

    [0, 0, -1], [1, 0, -1], [-1, 1, -1], [0, 1, -1], [1, 1, -1], [-1, -1, 0],

    [0, -1, 0], [1, -1, 0], [-1, 0, 0], [0, 0, 0], [1, 0, 0], [-1, 1, 0],

    [0, 1, 0], [1, 1, 0], [-1, -1, 1], [0, -1, 1], [1, -1, 1], [-1, 0, 1],

    [0, 0, 1], [1, 0, 1], [-1, 1, 1], [0, 1, 1], [1, 1, 1]]

> posn_list_3d_size4 := map(ListTools[Reverse],
> 			  hypercube_points([-1,-1,-1], [+2,+2,+2]));
posn_list_3d_size4 := [[-1, -1, -1], [0, -1, -1], [1, -1, -1], [2, -1, -1],

    [-1, 0, -1], [0, 0, -1], [1, 0, -1], [2, 0, -1], [-1, 1, -1], [0, 1, -1],

    [1, 1, -1], [2, 1, -1], [-1, 2, -1], [0, 2, -1], [1, 2, -1], [2, 2, -1],

    [-1, -1, 0], [0, -1, 0], [1, -1, 0], [2, -1, 0], [-1, 0, 0], [0, 0, 0],

    [1, 0, 0], [2, 0, 0], [-1, 1, 0], [0, 1, 0], [1, 1, 0], [2, 1, 0],

    [-1, 2, 0], [0, 2, 0], [1, 2, 0], [2, 2, 0], [-1, -1, 1], [0, -1, 1],

    [1, -1, 1], [2, -1, 1], [-1, 0, 1], [0, 0, 1], [1, 0, 1], [2, 0, 1],

    [-1, 1, 1], [0, 1, 1], [1, 1, 1], [2, 1, 1], [-1, 2, 1], [0, 2, 1],

    [1, 2, 1], [2, 2, 1], [-1, -1, 2], [0, -1, 2], [1, -1, 2], [2, -1, 2],

    [-1, 0, 2], [0, 0, 2], [1, 0, 2], [2, 0, 2], [-1, 1, 2], [0, 1, 2],

    [1, 1, 2], [2, 1, 2], [-1, 2, 2], [0, 2, 2], [1, 2, 2], [2, 2, 2]]

> posn_list_3d_size5 := map(ListTools[Reverse],
> 			  hypercube_points([-2,-2,-2], [+2,+2,+2]));
posn_list_3d_size5 := [[-2, -2, -2], [-1, -2, -2], [0, -2, -2], [1, -2, -2],

    [2, -2, -2], [-2, -1, -2], [-1, -1, -2], [0, -1, -2], [1, -1, -2],

    [2, -1, -2], [-2, 0, -2], [-1, 0, -2], [0, 0, -2], [1, 0, -2], [2, 0, -2],

    [-2, 1, -2], [-1, 1, -2], [0, 1, -2], [1, 1, -2], [2, 1, -2], [-2, 2, -2],

    [-1, 2, -2], [0, 2, -2], [1, 2, -2], [2, 2, -2], [-2, -2, -1], [-1, -2, -1],

    [0, -2, -1], [1, -2, -1], [2, -2, -1], [-2, -1, -1], [-1, -1, -1],

    [0, -1, -1], [1, -1, -1], [2, -1, -1], [-2, 0, -1], [-1, 0, -1], [0, 0, -1],

    [1, 0, -1], [2, 0, -1], [-2, 1, -1], [-1, 1, -1], [0, 1, -1], [1, 1, -1],

    [2, 1, -1], [-2, 2, -1], [-1, 2, -1], [0, 2, -1], [1, 2, -1], [2, 2, -1],

    [-2, -2, 0], [-1, -2, 0], [0, -2, 0], [1, -2, 0], [2, -2, 0], [-2, -1, 0],

    [-1, -1, 0], [0, -1, 0], [1, -1, 0], [2, -1, 0], [-2, 0, 0], [-1, 0, 0],

    [0, 0, 0], [1, 0, 0], [2, 0, 0], [-2, 1, 0], [-1, 1, 0], [0, 1, 0],

    [1, 1, 0], [2, 1, 0], [-2, 2, 0], [-1, 2, 0], [0, 2, 0], [1, 2, 0],

    [2, 2, 0], [-2, -2, 1], [-1, -2, 1], [0, -2, 1], [1, -2, 1], [2, -2, 1],

    [-2, -1, 1], [-1, -1, 1], [0, -1, 1], [1, -1, 1], [2, -1, 1], [-2, 0, 1],

    [-1, 0, 1], [0, 0, 1], [1, 0, 1], [2, 0, 1], [-2, 1, 1], [-1, 1, 1],

    [0, 1, 1], [1, 1, 1], [2, 1, 1], [-2, 2, 1], [-1, 2, 1], [0, 2, 1],

    [1, 2, 1], [2, 2, 1], [-2, -2, 2], [-1, -2, 2], [0, -2, 2], [1, -2, 2],

    [2, -2, 2], [-2, -1, 2], [-1, -1, 2], [0, -1, 2], [1, -1, 2], [2, -1, 2],

    [-2, 0, 2], [-1, 0, 2], [0, 0, 2], [1, 0, 2], [2, 0, 2], [-2, 1, 2],

    [-1, 1, 2], [0, 1, 2], [1, 1, 2], [2, 1, 2], [-2, 2, 2], [-1, 2, 2],

    [0, 2, 2], [1, 2, 2], [2, 2, 2]]

> posn_list_3d_size6 := map(ListTools[Reverse],
> 			  hypercube_points([-2,-2,-2], [+3,+3,+3]));
posn_list_3d_size6 := [[-2, -2, -2], [-1, -2, -2], [0, -2, -2], [1, -2, -2],

    [2, -2, -2], [3, -2, -2], [-2, -1, -2], [-1, -1, -2], [0, -1, -2],

    [1, -1, -2], [2, -1, -2], [3, -1, -2], [-2, 0, -2], [-1, 0, -2], [0, 0, -2],

    [1, 0, -2], [2, 0, -2], [3, 0, -2], [-2, 1, -2], [-1, 1, -2], [0, 1, -2],

    [1, 1, -2], [2, 1, -2], [3, 1, -2], [-2, 2, -2], [-1, 2, -2], [0, 2, -2],

    [1, 2, -2], [2, 2, -2], [3, 2, -2], [-2, 3, -2], [-1, 3, -2], [0, 3, -2],

    [1, 3, -2], [2, 3, -2], [3, 3, -2], [-2, -2, -1], [-1, -2, -1], [0, -2, -1],

    [1, -2, -1], [2, -2, -1], [3, -2, -1], [-2, -1, -1], [-1, -1, -1],

    [0, -1, -1], [1, -1, -1], [2, -1, -1], [3, -1, -1], [-2, 0, -1],

    [-1, 0, -1], [0, 0, -1], [1, 0, -1], [2, 0, -1], [3, 0, -1], [-2, 1, -1],

    [-1, 1, -1], [0, 1, -1], [1, 1, -1], [2, 1, -1], [3, 1, -1], [-2, 2, -1],

    [-1, 2, -1], [0, 2, -1], [1, 2, -1], [2, 2, -1], [3, 2, -1], [-2, 3, -1],

    [-1, 3, -1], [0, 3, -1], [1, 3, -1], [2, 3, -1], [3, 3, -1], [-2, -2, 0],

    [-1, -2, 0], [0, -2, 0], [1, -2, 0], [2, -2, 0], [3, -2, 0], [-2, -1, 0],

    [-1, -1, 0], [0, -1, 0], [1, -1, 0], [2, -1, 0], [3, -1, 0], [-2, 0, 0],

    [-1, 0, 0], [0, 0, 0], [1, 0, 0], [2, 0, 0], [3, 0, 0], [-2, 1, 0],

    [-1, 1, 0], [0, 1, 0], [1, 1, 0], [2, 1, 0], [3, 1, 0], [-2, 2, 0],

    [-1, 2, 0], [0, 2, 0], [1, 2, 0], [2, 2, 0], [3, 2, 0], [-2, 3, 0],

    [-1, 3, 0], [0, 3, 0], [1, 3, 0], [2, 3, 0], [3, 3, 0], [-2, -2, 1],

    [-1, -2, 1], [0, -2, 1], [1, -2, 1], [2, -2, 1], [3, -2, 1], [-2, -1, 1],

    [-1, -1, 1], [0, -1, 1], [1, -1, 1], [2, -1, 1], [3, -1, 1], [-2, 0, 1],

    [-1, 0, 1], [0, 0, 1], [1, 0, 1], [2, 0, 1], [3, 0, 1], [-2, 1, 1],

    [-1, 1, 1], [0, 1, 1], [1, 1, 1], [2, 1, 1], [3, 1, 1], [-2, 2, 1],

    [-1, 2, 1], [0, 2, 1], [1, 2, 1], [2, 2, 1], [3, 2, 1], [-2, 3, 1],

    [-1, 3, 1], [0, 3, 1], [1, 3, 1], [2, 3, 1], [3, 3, 1], [-2, -2, 2],

    [-1, -2, 2], [0, -2, 2], [1, -2, 2], [2, -2, 2], [3, -2, 2], [-2, -1, 2],

    [-1, -1, 2], [0, -1, 2], [1, -1, 2], [2, -1, 2], [3, -1, 2], [-2, 0, 2],

    [-1, 0, 2], [0, 0, 2], [1, 0, 2], [2, 0, 2], [3, 0, 2], [-2, 1, 2],

    [-1, 1, 2], [0, 1, 2], [1, 1, 2], [2, 1, 2], [3, 1, 2], [-2, 2, 2],

    [-1, 2, 2], [0, 2, 2], [1, 2, 2], [2, 2, 2], [3, 2, 2], [-2, 3, 2],

    [-1, 3, 2], [0, 3, 2], [1, 3, 2], [2, 3, 2], [3, 3, 2], [-2, -2, 3],

    [-1, -2, 3], [0, -2, 3], [1, -2, 3], [2, -2, 3], [3, -2, 3], [-2, -1, 3],

    [-1, -1, 3], [0, -1, 3], [1, -1, 3], [2, -1, 3], [3, -1, 3], [-2, 0, 3],

    [-1, 0, 3], [0, 0, 3], [1, 0, 3], [2, 0, 3], [3, 0, 3], [-2, 1, 3],

    [-1, 1, 3], [0, 1, 3], [1, 1, 3], [2, 1, 3], [3, 1, 3], [-2, 2, 3],

    [-1, 2, 3], [0, 2, 3], [1, 2, 3], [2, 2, 3], [3, 2, 3], [-2, 3, 3],

    [-1, 3, 3], [0, 3, 3], [1, 3, 3], [2, 3, 3], [3, 3, 3]]

# Maple code to compute common coefficients for all 2d interpolation schemes
# $Header$
> 
################################################################################
> 
#
# generic stuff for 2d, cube, size=2
#
> 
> data_list_2d_size2 := map(data_var_name, posn_list_2d_size2, "data_");
   data_list_2d_size2 := ["data_0_0", "data_p1_0", "data_0_p1", "data_p1_p1"]

> coeffs_list_2d_size2 := map(coeff_name, posn_list_2d_size2, "coeff_");
coeffs_list_2d_size2 :=

    ["coeff_0_0", "coeff_p1_0", "coeff_0_p1", "coeff_p1_p1"]

> 
> print_name_list_dcl(data_list_2d_size2, "fp",
> 		    "2d.cube.size2/data-dcl.h");
> print_name_list_dcl(coeffs_list_2d_size2, "fp",
> 		    "2d.cube.size2/coeffs-dcl.h");
> 
> print_fetch_data(posn_list_2d_size2, "data->data_",
> 		 "2d.cube.size2/fetch-data.c");
> print_evaluate_molecule(posn_list_2d_size2,
> 			"coeffs->coeff_", "data->data_",
> 			"2d.cube.size2/evaluate-molecule.c");
> print_store_coeffs(posn_list_2d_size2,
> 		   "factor * coeffs->coeff_",
> 		   "2d.cube.size2/store-coeffs.c");
> 
################################################################################
> 
#
# generic stuff for 2d, cube, size=3
#
> 
> data_list_2d_size3 := map(data_var_name, posn_list_2d_size3, "data_");
data_list_2d_size3 := ["data_m1_m1", "data_0_m1", "data_p1_m1", "data_m1_0",

    "data_0_0", "data_p1_0", "data_m1_p1", "data_0_p1", "data_p1_p1"]

> coeffs_list_2d_size3 := map(coeff_name, posn_list_2d_size3, "coeff_");
coeffs_list_2d_size3 := ["coeff_m1_m1", "coeff_0_m1", "coeff_p1_m1",

    "coeff_m1_0", "coeff_0_0", "coeff_p1_0", "coeff_m1_p1", "coeff_0_p1",

    "coeff_p1_p1"]

> 
> print_name_list_dcl(data_list_2d_size3, "fp",
> 		    "2d.cube.size3/data-dcl.h");
> print_name_list_dcl(coeffs_list_2d_size3, "fp",
> 		    "2d.cube.size3/coeffs-dcl.h");
> 
> print_fetch_data(posn_list_2d_size3, "data->data_",
> 		 "2d.cube.size3/fetch-data.c");
> print_evaluate_molecule(posn_list_2d_size3,
> 			"coeffs->coeff_", "data->data_",
> 			"2d.cube.size3/evaluate-molecule.c");
> print_store_coeffs(posn_list_2d_size3,
> 		   "factor * coeffs->coeff_",
> 		   "2d.cube.size3/store-coeffs.c");
> 
################################################################################
> 
#
# generic stuff for 2d, cube, size=4
#
> 
> data_list_2d_size4 := map(data_var_name, posn_list_2d_size4, "data_");
data_list_2d_size4 := ["data_m1_m1", "data_0_m1", "data_p1_m1", "data_p2_m1",

    "data_m1_0", "data_0_0", "data_p1_0", "data_p2_0", "data_m1_p1",

    "data_0_p1", "data_p1_p1", "data_p2_p1", "data_m1_p2", "data_0_p2",

    "data_p1_p2", "data_p2_p2"]

> coeffs_list_2d_size4 := map(coeff_name, posn_list_2d_size4, "coeff_");
coeffs_list_2d_size4 := ["coeff_m1_m1", "coeff_0_m1", "coeff_p1_m1",

    "coeff_p2_m1", "coeff_m1_0", "coeff_0_0", "coeff_p1_0", "coeff_p2_0",

    "coeff_m1_p1", "coeff_0_p1", "coeff_p1_p1", "coeff_p2_p1", "coeff_m1_p2",

    "coeff_0_p2", "coeff_p1_p2", "coeff_p2_p2"]

> 
> print_name_list_dcl(data_list_2d_size4, "fp",
> 		    "2d.cube.size4/data-dcl.h");
> print_name_list_dcl(coeffs_list_2d_size4, "fp",
> 		    "2d.cube.size4/coeffs-dcl.h");
> 
> print_fetch_data(posn_list_2d_size4, "data->data_",
> 		 "2d.cube.size4/fetch-data.c");
> print_evaluate_molecule(posn_list_2d_size4,
> 			"coeffs->coeff_", "data->data_",
> 			"2d.cube.size4/evaluate-molecule.c");
> print_store_coeffs(posn_list_2d_size4,
> 		   "factor * coeffs->coeff_",
> 		   "2d.cube.size4/store-coeffs.c");
> 
################################################################################
> 
#
# generic stuff for 2d, cube, size=5
#
> 
> data_list_2d_size5 := map(data_var_name, posn_list_2d_size5, "data_");
data_list_2d_size5 := ["data_m2_m2", "data_m1_m2", "data_0_m2", "data_p1_m2",

    "data_p2_m2", "data_m2_m1", "data_m1_m1", "data_0_m1", "data_p1_m1",

    "data_p2_m1", "data_m2_0", "data_m1_0", "data_0_0", "data_p1_0",

    "data_p2_0", "data_m2_p1", "data_m1_p1", "data_0_p1", "data_p1_p1",

    "data_p2_p1", "data_m2_p2", "data_m1_p2", "data_0_p2", "data_p1_p2",

    "data_p2_p2"]

> coeffs_list_2d_size5 := map(coeff_name, posn_list_2d_size5, "coeff_");
coeffs_list_2d_size5 := ["coeff_m2_m2", "coeff_m1_m2", "coeff_0_m2",

    "coeff_p1_m2", "coeff_p2_m2", "coeff_m2_m1", "coeff_m1_m1", "coeff_0_m1",

    "coeff_p1_m1", "coeff_p2_m1", "coeff_m2_0", "coeff_m1_0", "coeff_0_0",

    "coeff_p1_0", "coeff_p2_0", "coeff_m2_p1", "coeff_m1_p1", "coeff_0_p1",

    "coeff_p1_p1", "coeff_p2_p1", "coeff_m2_p2", "coeff_m1_p2", "coeff_0_p2",

    "coeff_p1_p2", "coeff_p2_p2"]

> 
> print_name_list_dcl(data_list_2d_size5, "fp",
> 		    "2d.cube.size5/data-dcl.h");
> print_name_list_dcl(coeffs_list_2d_size5, "fp",
> 		    "2d.cube.size5/coeffs-dcl.h");
> 
> print_fetch_data(posn_list_2d_size5, "data->data_",
> 		 "2d.cube.size5/fetch-data.c");
> print_evaluate_molecule(posn_list_2d_size5,
> 			"coeffs->coeff_", "data->data_",
> 			"2d.cube.size5/evaluate-molecule.c");
> print_store_coeffs(posn_list_2d_size5,
> 		   "factor * coeffs->coeff_",
> 		   "2d.cube.size5/store-coeffs.c");
> 
################################################################################
> 
#
# generic stuff for 2d, cube, size=6
#
> 
> data_list_2d_size6 := map(data_var_name, posn_list_2d_size6, "data_");
data_list_2d_size6 := ["data_m2_m2", "data_m1_m2", "data_0_m2", "data_p1_m2",

    "data_p2_m2", "data_p3_m2", "data_m2_m1", "data_m1_m1", "data_0_m1",

    "data_p1_m1", "data_p2_m1", "data_p3_m1", "data_m2_0", "data_m1_0",

    "data_0_0", "data_p1_0", "data_p2_0", "data_p3_0", "data_m2_p1",

    "data_m1_p1", "data_0_p1", "data_p1_p1", "data_p2_p1", "data_p3_p1",

    "data_m2_p2", "data_m1_p2", "data_0_p2", "data_p1_p2", "data_p2_p2",

    "data_p3_p2", "data_m2_p3", "data_m1_p3", "data_0_p3", "data_p1_p3",

    "data_p2_p3", "data_p3_p3"]

> coeffs_list_2d_size6 := map(coeff_name, posn_list_2d_size6, "coeff_");
coeffs_list_2d_size6 := ["coeff_m2_m2", "coeff_m1_m2", "coeff_0_m2",

    "coeff_p1_m2", "coeff_p2_m2", "coeff_p3_m2", "coeff_m2_m1", "coeff_m1_m1",

    "coeff_0_m1", "coeff_p1_m1", "coeff_p2_m1", "coeff_p3_m1", "coeff_m2_0",

    "coeff_m1_0", "coeff_0_0", "coeff_p1_0", "coeff_p2_0", "coeff_p3_0",

    "coeff_m2_p1", "coeff_m1_p1", "coeff_0_p1", "coeff_p1_p1", "coeff_p2_p1",

    "coeff_p3_p1", "coeff_m2_p2", "coeff_m1_p2", "coeff_0_p2", "coeff_p1_p2",

    "coeff_p2_p2", "coeff_p3_p2", "coeff_m2_p3", "coeff_m1_p3", "coeff_0_p3",

    "coeff_p1_p3", "coeff_p2_p3", "coeff_p3_p3"]

> 
> print_name_list_dcl(data_list_2d_size6, "fp",
> 		    "2d.cube.size6/data-dcl.h");
> print_name_list_dcl(coeffs_list_2d_size6, "fp",
> 		    "2d.cube.size6/coeffs-dcl.h");
> 
> print_fetch_data(posn_list_2d_size6, "data->data_",
> 		 "2d.cube.size6/fetch-data.c");
> print_evaluate_molecule(posn_list_2d_size6,
> 			"coeffs->coeff_", "data->data_",
> 			"2d.cube.size6/evaluate-molecule.c");
> print_store_coeffs(posn_list_2d_size6,
> 		   "factor * coeffs->coeff_",
> 		   "2d.cube.size6/store-coeffs.c");
> quit
bytes used=976064, alloc=917336, time=0.08
